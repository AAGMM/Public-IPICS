// -------------------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License (MIT). See LICENSE in the repo root for license information.
// -------------------------------------------------------------------------------------------------

using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using EnsureThat;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.DurableTask;
using Microsoft.Extensions.Logging;
using Microsoft.Health.Dicom.Core.Extensions;
using Microsoft.Health.Dicom.Core.Features.ExtendedQueryTag;
using Microsoft.Health.Dicom.Core.Features.Model;
using Microsoft.Health.Dicom.Functions.Extensions;
using Microsoft.Health.Dicom.Functions.Indexing.Models;

namespace Microsoft.Health.Dicom.Functions.Indexing
{
    public partial class ReindexDurableFunction
    {
        /// <summary>
        /// Asynchronously creates an index for the provided query tags over the previously added data.
        /// </summary>
        /// <remarks>
        /// Durable functions are reliable, and their implementations will be executed repeatedly over the lifetime of
        /// a single instance.
        /// </remarks>
        /// <param name="context">The context for the orchestration instance.</param>
        /// <param name="logger">A diagnostic logger.</param>
        /// <returns>A task representing the <see cref="ReindexInstancesAsync"/> operation.</returns>
        [FunctionName(nameof(ReindexInstancesAsync))]
        public async Task ReindexInstancesAsync(
            [OrchestrationTrigger] IDurableOrchestrationContext context,
            ILogger logger)
        {
            EnsureArg.IsNotNull(context, nameof(context));

            // The ID should be a GUID as generated by the trigger, but we'll assert here just to make sure!
            if (!context.HasInstanceGuid())
            {
                return;
            }

            logger = context.CreateReplaySafeLogger(logger);
            ReindexInput input = context.GetInput<ReindexInput>();

            // Fetch the set of query tags that require re-indexing
            IReadOnlyList<ExtendedQueryTagStoreEntry> queryTags = await GetOperationQueryTagsAsync(context, input);
            logger.LogInformation(
                "Found {Count} extended query tag paths to re-index {{{QueryTags}}}.",
                queryTags.Count,
                string.Join(", ", queryTags.Select(x => x.Path)));

            if (queryTags.Count > 0)
            {
                List<ExtendedQueryTagReference> queryTagReferences = queryTags.Select(x => x.ToReference()).ToList();
                IReadOnlyList<WatermarkRange> batches = await context.CallActivityWithRetryAsync<IReadOnlyList<WatermarkRange>>(
                    nameof(GetInstanceBatchesAsync),
                    _options.ActivityRetryOptions,
                    input.Completed?.Start - 1);

                if (batches.Count > 0)
                {
                    // Note that batches are in reverse order because we start from the highest watermark
                    var batchRange = new WatermarkRange(batches[^1].Start, batches[0].End);

                    logger.LogInformation("Beginning to re-index the range {Range}.", batchRange);
                    await Task.WhenAll(batches
                        .Select(x => context.CallActivityWithRetryAsync(
                            nameof(ReindexBatchAsync),
                            _options.ActivityRetryOptions,
                            new ReindexBatch { QueryTags = queryTags, WatermarkRange = x })));

                    // Create a new orchestration with the same instance ID to process the remaining data
                    logger.LogInformation("Completed re-indexing the range {Range}. Continuing with new execution...", batchRange);

                    WatermarkRange completed = input.Completed.HasValue
                        ? new WatermarkRange(batchRange.Start, input.Completed.Value.End)
                        : batchRange;

                    context.ContinueAsNew(
                        new ReindexInput
                        {
                            QueryTags = queryTagReferences,
                            Completed = completed,
                        });
                }
                else
                {
                    IReadOnlyList<ExtendedQueryTagReference> completed = await context.CallActivityWithRetryAsync<IReadOnlyList<ExtendedQueryTagReference>>(
                        nameof(CompleteReindexingAsync),
                        _options.ActivityRetryOptions,
                        queryTagReferences);

                    logger.LogInformation(
                        "Completed re-indexing for the following extended query tags {{{QueryTags}}}.",
                        string.Join(", ", completed.Select(x => x.Path)));
                }
            }
            else
            {
                logger.LogWarning(
                    "Could not find any query tags for the re-indexing operation '{OperationId}'.",
                    context.InstanceId);
            }
        }

        private Task<IReadOnlyList<ExtendedQueryTagStoreEntry>> GetOperationQueryTagsAsync(IDurableOrchestrationContext context, ReindexInput input)
            // Determine the set of query tags that should be indexed and only continue if there is at least 1.
            // For the first time this orchestration executes, assign all of the tags in the input to the operation,
            // otherwise simply fetch the tags from the database for this operation.
            => input.Completed.HasValue
                ? context.CallActivityWithRetryAsync<IReadOnlyList<ExtendedQueryTagStoreEntry>>(
                    nameof(GetQueryTagsAsync),
                    _options.ActivityRetryOptions,
                    null)
                : context.CallActivityWithRetryAsync<IReadOnlyList<ExtendedQueryTagStoreEntry>>(
                    nameof(AssignReindexingOperationAsync),
                    _options.ActivityRetryOptions,
                    input.QueryTags);
    }
}
